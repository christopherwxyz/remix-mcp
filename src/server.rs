//! MCP Server implementation for Ableton Live control.

use rmcp::handler::server::router::tool::ToolRouter;
use rmcp::handler::server::tool::ToolCallContext;
use rmcp::model::*;
use rmcp::service::RequestContext;
use rmcp::{RoleServer, ServerHandler};
use tracing::info;

use crate::osc::OscHandle;

/// MCP Server for controlling Ableton Live via OSC.
#[derive(Clone)]
pub struct AbletonServer {
    pub(crate) osc: OscHandle,
    tool_router: ToolRouter<Self>,
}

impl Default for AbletonServer {
    fn default() -> Self {
        Self::new()
    }
}

impl AbletonServer {
    /// Create a new Ableton MCP server.
    ///
    /// This is infallible â€” no network sockets are opened until the first tool
    /// call. This ensures the MCP handshake always succeeds, even when port
    /// 11001 is busy or Ableton is not running.
    pub fn new() -> Self {
        let osc = OscHandle::new();

        // Merge all tool routers (these are associated functions generated by #[tool_router])
        let tool_router = Self::transport_router()
            + Self::view_router()
            + Self::cue_points_router()
            + Self::scenes_router()
            + Self::devices_router()
            + Self::browser_router()
            + Self::song_router()
            + Self::tracks_router()
            + Self::clips_router()
            + Self::application_router()
            + Self::midimap_router();

        info!(
            "AbletonServer initialized with {} tools",
            tool_router.list_all().len()
        );

        Self { osc, tool_router }
    }
}

impl ServerHandler for AbletonServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::V_2024_11_05,
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            server_info: Implementation::from_build_env(),
            instructions: Some(
                "Control Ableton Live via OSC. Requires AbletonOSC Remote Script to be installed and enabled in Ableton Live.".into(),
            ),
        }
    }

    fn list_tools(
        &self,
        _request: Option<PaginatedRequestParams>,
        _context: RequestContext<RoleServer>,
    ) -> impl std::future::Future<Output = Result<ListToolsResult, rmcp::ErrorData>> + Send + '_
    {
        async move {
            Ok(ListToolsResult {
                tools: self.tool_router.list_all(),
                next_cursor: None,
                meta: None,
            })
        }
    }

    fn call_tool(
        &self,
        request: CallToolRequestParams,
        context: RequestContext<RoleServer>,
    ) -> impl std::future::Future<Output = Result<CallToolResult, rmcp::ErrorData>> + Send + '_
    {
        async move {
            let tool_context = ToolCallContext::new(self, request, context);
            self.tool_router.call(tool_context).await
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// `AbletonServer::new()` always succeeds and has tools registered.
    #[test]
    fn server_new_is_infallible() {
        let server = AbletonServer::new();
        let tools = server.tool_router.list_all();
        assert!(!tools.is_empty(), "server should have tools registered");
    }
}
