//! MCP Server implementation for Ableton Live control.

use std::sync::Arc;

use rmcp::handler::server::router::tool::ToolRouter;
use rmcp::handler::server::tool::ToolCallContext;
use rmcp::model::*;
use rmcp::service::RequestContext;
use rmcp::{RoleServer, ServerHandler};
use tracing::info;

use crate::error::Error;
use crate::osc::OscClient;

/// MCP Server for controlling Ableton Live via OSC.
#[derive(Clone)]
pub struct AbletonServer {
    pub(crate) osc: Arc<OscClient>,
    tool_router: ToolRouter<Self>,
}

impl AbletonServer {
    /// Create a new Ableton MCP server.
    pub async fn new() -> Result<Self, Error> {
        let osc = OscClient::new().await?;

        // Merge all tool routers (these are associated functions generated by #[tool_router])
        let tool_router = Self::transport_router()
            + Self::view_router()
            + Self::cue_points_router()
            + Self::scenes_router()
            + Self::devices_router()
            + Self::browser_router()
            + Self::song_router()
            + Self::tracks_router()
            + Self::clips_router()
            + Self::application_router()
            + Self::midimap_router();

        info!(
            "AbletonServer initialized with {} tools",
            tool_router.list_all().len()
        );

        Ok(Self {
            osc: Arc::new(osc),
            tool_router,
        })
    }
}

impl ServerHandler for AbletonServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::V_2024_11_05,
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            server_info: Implementation::from_build_env(),
            instructions: Some(
                "Control Ableton Live via OSC. Requires AbletonOSC Remote Script to be installed and enabled in Ableton Live.".into(),
            ),
        }
    }

    fn list_tools(
        &self,
        _request: Option<PaginatedRequestParams>,
        _context: RequestContext<RoleServer>,
    ) -> impl std::future::Future<Output = Result<ListToolsResult, rmcp::ErrorData>> + Send + '_
    {
        async move {
            Ok(ListToolsResult {
                tools: self.tool_router.list_all(),
                next_cursor: None,
                meta: None,
            })
        }
    }

    fn call_tool(
        &self,
        request: CallToolRequestParams,
        context: RequestContext<RoleServer>,
    ) -> impl std::future::Future<Output = Result<CallToolResult, rmcp::ErrorData>> + Send + '_
    {
        async move {
            let tool_context = ToolCallContext::new(self, request, context);
            self.tool_router.call(tool_context).await
        }
    }
}
